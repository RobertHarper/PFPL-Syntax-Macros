\documentclass[11pt]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[color=yellow,textwidth=1.0in]{todonotes}
\setlength{\marginparwidth}{1.25in}
\usepackage{amsmath,amssymb,amsthm,mathtools,stmaryrd}
\usepackage{url}

\usepackage[abt]{pfpl-syntax}
\usepackage{pfpl-judgments}

\title{\textsf{PFPL} Judgments Package%
\footnote{\copyright{} \the\year{} Robert Harper.  All Rights Reserved.}}
\author{Robert Harper}
\date{\today}

\begin{document}

\maketitle{}

\section*{Overview}

Include the declaration \verb|\usepackage{pfpl-judgments}| to define macros for the judgment forms that are typically used when defining programming languages.  See the source code for this document for the names of the macros and their use.

All languages in \textsf{PFPL} are \emph{phase separated} in that there is an \emph{a priori} distinction between the \emph{statics} and \emph{dynamics} of a language, with the statics specifying context-sensitive conditions on the formation of pieces of syntax, and the dynamics specifying the evaluation or execution of programs.

\section*{Statics}


\subsection*{Basic Judgments}

Languages with a phase separation distinguish types, which classify values, from expressions, which evaluate to values.  Languages with effects have a \emph{modal separation} between expressions and commands, the latter of which are classified by the types of their returned values.  Languages with \emph{explicit control} classify contexts aka continuations by the type of value that they accept.

In richer languages there are non-trivial notions of equality of types, and correspondingly equality of constructors, and in languages with dependent kinds, there is also equality of kinds.  In all cases classification respects equality of classifiers.  In some cases there is also a notion of subtyping, and singleton kinds induce forgetful subkinding relations.  Subsumption specifies that typing and kinding respect these relations.

The basic judgment forms corresponding to this architecture are summarized in Figure~\ref{fig:statics}.

\subsection*{Hypothetical/General Judgments}

The combined hypothetical-general judgment, written $\Gamma\entails J$ or $\Delta\entails J$, expresses assumptions the variables that may be involved in the principal judgment, $J$.  In keeping with the phase distinction there are two classes of variables, the static variables, which range over types and constructors, and the dynamic variables, which range over a type.  In the presence of partiality (undefined expressions) variables may range over either unevaluated expressions or over values, with the latter being the dominant form throughout.  Conventionally, static variables, which range over a kind, are declared in a context written $\Delta$, and dynamic variables, which range over a type, are declared in a context $\Gamma$.  When both forms of context are involved, the notation $\sepCtx{\Delta}{\Gamma}\entails J$ is used.

Because variables are given meaning by substitution, the assumptions governing them must always be of the same form as those governing that which is substituted.  Although there are always variables ranging over a type, there may or may not be variables ranging over a kind.  The phase separation demands that the formation of kinds does not depend on variables of a type.  In general contexts have the form
\[
    \extCtx{\extCtx{\empCtx}{j_1}\dots}{j_n}
\]
where $n\geq 0$ and the $j_i$'s are variable declarations.  Here $\empCtx$ is the empty context, which is usually omitted, except occasionally for emphasis.

Thus, the type formation judgment, $\isTp{\tau}$, may be extended to the hypothetical form $\Delta\entails\isTp{\tau}$, where $\Delta$ is a context of the form
\[
    \extCtx{\isTp{t_1}\dots}{\isTp{t_n}}
\]
declaring that the $t_i$'s are type variables.  When kinds are involved, such a context has the form
\[
    \extCtx{\isOfKd*{u_1}{\kappa_1}\dots}{\isOfKd{u_n}{\kappa_n}}.
\]
Similarly, the expression typing judgment may be extended to the hypothetical form $\Gamma\entails \isOf{e}{\tau}$, where $\Gamma$ is a context of the form
\[
    \extCtx{\isOf*{x_1}{\tau_1}\dots}{\isOf*{x_n}{\tau_n}}
\]
where the $x_i$'s are expression variables, and the $\tau_i$'s are types.  When both forms of variable are involved in an expression typing, the hypothetical form $\sepCtx{\Delta}{\Gamma}\entails \isOf{e}{\tau}$ is used.

When effects are permitted, commands are classified by types, but there are no variables ranging over commands.  There are, however, \emph{symbols}, such as the names of assignables, to which a type is \emph{associated}.  These are declared using \emph{signatures}, $\Sigma$, of the form
\[
    \extSig{\extSig{\empSig}{\hasTp{a_1}{\tau_1}}\dots}{\hasTp{a_n}{\tau_n}}
\]
where the $a_i$'s are distinct symbols, which stand only for themselves and which may be compared for equality and disequality.  Signature concatenation is written $\appSig{\Sigma_1}{\Sigma_2}$.  As with contexts, the empty signature is usually left implicit.  The statics of commands is then given by hypothetical judgments of the form $\Gamma\entails[\Sigma] \isOf{e}{\tau}$ and $\Gamma\entails[\Sigma] \hasTp{m}{\tau}$, where $m$ is a command.  Thus, the signature governs the usage of symbols within expressions and commands.

\smallskip

The entailment notation for hypothetical judgments is reserved for situations in which it expresses a \emph{structural consequence relation}, one that admits reflexivity (assumptions entail themselves) and transitivity aka substitution for variables, and is closed under weakening (addition of unused variables).  Symbols, being distinct from variables, enjoy no such properties, though usually signatures are treated so as to ignore any extra symbols beyond what is required in a given situation.

\begin{figure}[p]
    \begin{displaymath}
        \begin{array}{l@{\qquad} l@{\qquad}l}
            \text{Judgment}   & \text{Meaning}  & \text{Invocation} \\
            \isTp{\tau}            & \tau\ \text{is a type} & \verb|\isTp{\tau}| \\
            \eqTp{\tau}{\tau'}     & \tau\ \text{and}\ \tau'\ \text{are equal types} & \verb|\eqTp{\tau}{\tau'}| \\
            \subTp{\tau}{\tau'}    & \tau\ \text{is a subtype of}\ \tau' & \verb|\subTp{\tau}{\tau'}| \\\\
            \isKd{\kappa}          & \kappa\ \text{is a kind} & \verb|\isKd{\kappa}| \\
            \eqKd{\kappa}{\kappa'} & \kappa\ \text{and}\ \kappa'\ \text{are equal kinds} & \verb|\eqKd{\kappa}{\kappa'}| \\
            \subKd{\kappa}{\kappa'} & \kappa\ \text{is a subkind of}\ \kappa' & \verb|\subKd{\kappa}{\kappa'}| \\\\
            \isOfKd{c}{\kappa}   & c\ \text{has kind}\ \kappa & \verb|\isOfKd{c}{\kappa}| \\
            \eqOfKd{c}{c'}{\kappa} & c\ \text{and}\ c'\ \text{are equal at kind}\ \kappa & \verb|\eqOfKd{c}{c'}{\kappa}| \\\\
            \isOfTp{e}{\tau}         & e\ \text{has type}\ \tau & \verb|\isOfTp{e}{\tau}|, \verb|\isOf{e}{\tau}| \\
            \retsTp{m}{\tau}       & m\ \text{returns type}\ \tau & \verb|\retsTp{m}{\tau}| \\
            \accsTp{k}{\tau}       & k\ \text{accepts type}\ \tau  & \verb|\accsTp{k}{\tau}| \\\\
            \isCtx{\Gamma}         & \Gamma\ \text{is a valid context} & \verb|\isCtx{\Gamma}| \\
            \isSig{\Sigma}         & \Sigma\ \text{is a valid signature} & \verb|\isSig{\Sigma}|
        \end{array}
    \end{displaymath}

    \caption{Judgments for Statics}
    \label{fig:statics}
\end{figure}

\section*{Dynamics}

Throughout \textsf{PFPL} the dynamics of languages is formulated using \emph{state transition systems}, which define a class of execution states, some of which are deemed initial, some of which are deemed final, and a relation between states that expresses ``one step'' of execution.  In principle a state can be anything at all, but in practice states are constructed from (closed, well-formed) pieces of syntax, perhaps involving symbols, and sometimes involving auxiliary data structures such as memories.  These considerations lead to the judgment forms given in Figure~\ref{fig:dynamics}.

There are, invariably, unlabelled forms of transition that may, or may not, be indexed by a signature defining the symbols that are available within the state.  Labelled forms are further indexed by an \emph{action} that specifies the effect of a step of execution.  Generally speaking, such transitions are not execution steps \textit{per se}, but are rather potential steps that may be taken in conjunction with another, complementary, transition.

\smallskip

Occasionally it is helpful to introduce evaluation relations for expressions and execution relations for commands that consolidate multiple individual steps of execution to a final state.  These are also specified, for expressions, in Figure~\ref{fig:dynamics}.  Technically speaking, these relations are strictly secondary to the transition systems that define execution, and are used as summaries of the individual steps.  For example, in the context of an imperative language, evaluation is used for expressions in the definition of transition for commands.

\smallskip

Hypothetical judgment forms for dynamics do not arise in \textsf{PFPL}, and so are not considered here.

\begin{figure}[p]
    \begin{displaymath}
        \begin{array}{l@{\qquad}l@{\qquad}l}
            \text{Judgment} & \text{Meaning} & \text{Invocation} \\
            \okSt[\Sigma]{s}       & s\ \text{is an ok state} & \verb|\okSt[\Sigma]{s}| \\
            \iniSt[\Sigma]{s}            & s\ \text{is initial}\ (\text{rel.} \Sigma) & \verb|\iniSt[\Sigma]{s}|, \verb|\isIni[\Sigma]{s}| \\
            \finSt[\Sigma]{s}            & s\ \text{is final}\ (\text{rel.} \Sigma) & \verb|\finSt[\Sigma]{s}|, \verb|\isFin[\Sigma]{s}| \\\\
            %
            s\stepsTo[\Sigma] s' & s\ \text{steps to}\ s'\ (\text{rel.}\ \Sigma) & \verb|s\stepsTo[\Sigma] s'| \\
            s\stepsTo[\Sigma](\ast) s' & s\ \text{multisteps to}\ s'\ (\text{rel.}\ \Sigma) & \verb|s\stepsTo[\Sigma](\ast)| \\\\
            %
            s\stepsTo[\Sigma]<\alpha> s' & s\ \text{steps to}\ s'\ \text{with action}\ \alpha\ (\text{rel.}\ \Sigma) & \verb|s\stepsTo[\Sigma]<\alpha> s'| \\\\
            %
            \isVal[\Sigma]{e}    & e\ \text{is a value}\ (\text{rel.}\ \Sigma) & \verb|\isVal[\Sigma]{e}| \\\\
            e\evalsTo v          & e\ \text{evaluates to}\ v & \verb|e\evalsTo v| \\
            e\evalsTo(c) v       & e\ \text{evaluates to}\ v\ \text{with cost}\ c & \verb|e\evalsTo(c) v| \\\\
            %
            e\raisesUp v           & e\ \text{raises}\ v & \verb|e\raisesUp v| \\
            e\raisesUp(c) v        & e\ \text{raises}\ v\ \text{with cost}\ c & \verb|e\raisesUp(c) v| \\\\
            %
            e\hasResult v    & e\ \text{evaluates or raises}\ v & \verb|e\hasResult v| \\
            e\hasResult(c) v    & e\ \text{evaluates or raises}\ v\ \text{with cost}\ c  & \verb|e\hasResult(c) v|
        \end{array}
    \end{displaymath}

    \caption{Judgments for Dynamics}
    \label{fig:dynamics}
\end{figure}

\end{document}

