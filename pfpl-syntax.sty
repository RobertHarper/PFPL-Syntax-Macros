\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{pfpl-syntax}[2022/01/15 1.0.0 PFPL Syntax Macros]
\RequirePackage{amsmath,amssymb,amsthm,mathtools,stmaryrd,bigplustimes}
\RequirePackage{xifthen}

% camel case is used for internal macros in the vain hope to avoid conflicts.
% latex desperately needs sensible scoping of identifiers!

\ProvideDocumentCommand{\kw}{m}{\texttt{#1}}
\ProvideDocumentCommand{\singmap}{m m}{#1\hookrightarrow #2}
\ProvideDocumentCommand{\finmap}{s m m m}{\IfBooleanTF{#1}{#4_{#2}}{\singmap{#3}{#4_#3}\mid #3\in #2}}

\NewDocumentCommand{\sep}{}{\mathbin{;}}

% starred for math name, non-starred for verbatim name, optional index
\NewDocumentCommand{\Opn}{s m d<>}{\mathop{\IfBooleanTF{#1}{#2}{\kw{#2}}\IfValueT{#3}{\langle #3\rangle}{}}}

% abstractor of symbols in <>'s and variables in ()'s in an abt
\NewDocumentCommand{\Abs}{d<> d() m}{\IfValueT{#1}{#1\mathbin{.}}\IfValueT{#2}{#2\mathbin{.}} #3}
% abstract binding tree with operator, index, option, and argument
% starred form omits the index and option
\NewDocumentCommand{\Abt}{s m d<> o m}{\mathop{#2}\nolimits\IfValueT{#3}{\langle #3\rangle}\IfBooleanTF{#1}{}{\IfValueT{#4}{[#4]}}\ifthenelse{\isempty{#5}}{}{(#5)}}

% choose starred form of \Abt according to argument
\NewDocumentCommand{\Abtsw}{m m}{\IfBooleanTF{#1}{\Abt*{#2}}{\Abt{#2}}}

% product types
% nullary
\NewDocumentCommand{\unitTy}{s}{\Abt{\IfBooleanTF{#1}{\Opn*{\mathbf{1}}}{\Opn{unit}}}{}}
\NewDocumentCommand{\unitEx}{s}{\IfBooleanTF{#1}{\langle\rangle}{\Abt{\Opn{null}}{}}}
% binary
\NewDocumentCommand{\prodAbt}{m m}{\Abt{\Opn{prod}}{#1\sep#2}}
\NewDocumentCommand{\prodCst}{m m}{#1\times #2}
\NewDocumentCommand{\prodTy}{s m m}{\IfBooleanTF{#1}{\prodCst{#2}{#3}}{\prodAbt{#2}{#3}}}
\NewDocumentCommand{\pairAbt}{m m m m}{\Abt{\Opn{pair}}[#1\sep #2]{#3\sep #4}}
\NewDocumentCommand{\pairCst}{m m}{\langle #1, #2\rangle}
\NewDocumentCommand{\pairEx}{s O{\tau_1} O{\tau_2} m m}{\IfBooleanTF{#1}{\pairCst{#4}{#5}}{\pairAbt{#2}{#3}{#4}{#5}}}
\NewDocumentCommand{\projAbt}{m m m m}{\Abt{\Opn{proj}<#1>}[#2\sep #3]{#4}}
\NewDocumentCommand{\projCst}{m m}{#2\cdot #1}
\NewDocumentCommand{\projEx}{s D<>{i} O{\tau_1} O{\tau_2} m}{\IfBooleanTF{#1}{\projCst{#2}{#5}}{\projAbt{#2}{#3}{#4}{#5}}}
% n-ary
\NewDocumentCommand{\vprodAbt}{m m m}{\Abt{\Opn{vprod}}<#1>{\finmap*{#1}{#2}{#3}}}
\NewDocumentCommand{\vprodCst}{m m m}{\bigtimes_{#2\in #1}(\singmap{#2}{{#3}_{#2}})}
\NewDocumentCommand{\vprodTy}{s D<>{I} D<>{i} m}{\IfBooleanTF{#1}{\vprodCst{#2}{#3}{#4}}{\vprodAbt{#2}{#3}{#4}}}
\NewDocumentCommand{\vtupleAbt}{m m m m}{\Abt{\Opn{vtuple}<#1>}[#3_#1]{\finmap*{#1}{#2}{#4}}}
\NewDocumentCommand{\vtupleCst}{m m m}{\langle \singmap{#2}{#3_{#2}}\mid #2\in #1\rangle}
\NewDocumentCommand{\vtupleEx}{s D<>{I} D<>{i} O{\tau} m}{\IfBooleanTF{#1}{\vtupleCst{#2}{#3}{#5}}{\vtupleAbt{#2}{#3}{#4}{#5}}}
\NewDocumentCommand{\vprojAbt}{m m m m}{\Abt{\Opn{vproj}<#2>}<#1>[#3_{#1}]{#4}}
\NewDocumentCommand{\vprojCst}{m m}{#2\cdot #1}
\NewDocumentCommand{\vprojEx}{s D<>{I} D<>{i} O{\tau} m}{\IfBooleanTF{#1}{\vprojCst{#3}{#5}}{\vprojAbt{#2}{#3}{#4}{#5}}}

% sum types
% nullary
\NewDocumentCommand{\voidTy}{s}{\Abt{\IfBooleanTF{#1}{\Opn*{\mathbf{0}}}{\Opn{void}}}{}}
\NewDocumentCommand{\absurdEx}{s O{\rho} m}{\Abtsw{#1}{\Opn{absurd}}[#2]{#3}}  % fix me
% binary
\NewDocumentCommand{\sumAbt}{m m}{\Abt{\Opn{sum}}{#1\sep  #2}}
\NewDocumentCommand{\sumCst}{m m}{#1+#2}
\NewDocumentCommand{\sumTy}{s m m}{\IfBooleanTF{#1}{\sumCst{#2}{#3}}{\sumAbt{#2}{#3}}}
\NewDocumentCommand{\injAbt}{d<> m m m}{\Abt{\Opn{inj}<#1>}[#2\sep #3]{#4}}
\NewDocumentCommand{\injCst}{d<> m}{#1\cdot #2}
\NewDocumentCommand{\injEx}{s D<>{i} O{\tau_1} O{\tau_2} m}{\IfBooleanTF{#1}{\injCst<#2>{#5}}{\injAbt<#2>{#3}{#4}{#5}}}
\NewDocumentCommand{\caseAbt}{m m m m m}{\Abt{\Opn{case}}[#1_1\sep  #1_2\sep  #2]{#3\sep  \Abs(#4){#5_1}\sep  \Abs(#4){#5_2}}}
\NewDocumentCommand{\caseCst}{m m m}{\Opn{case}\, #1\,\{\Abs(#2){#3_1} \mid \Abs(#2){#3_2}\}}
\NewDocumentCommand{\caseEx}{s O{\tau} O{\rho} m m m}{\IfBooleanTF{#1}{\caseCst{#4}{#5}{#6}}{\caseAbt{#2}{#3}{#4}{#5}{#6}}}
% n-ary
\NewDocumentCommand{\vsumAbt}{m m m}{\Abt{\Opn{vsum}}<#1>{\finmap*{#1}{#2}{#3}}}
\NewDocumentCommand{\vsumCst}{m m m}{\bigplus_{#2\in #1}(\singmap{#2}{{#3}_{#2}})}
\NewDocumentCommand{\vsumTy}{s D<>{I} D<>{i} m}{\IfBooleanTF{#1}{\vsumCst{#2}{#3}{#4}}{\vsumAbt{#2}{#3}{#4}}}
\NewDocumentCommand{\vinjAbt}{m m m m}{\Abt{\Opn{vinj}<#2>}<#1>[#3_{#1}]{#4}}
\NewDocumentCommand{\vinjCst}{m m}{#1\cdot #2}
\NewDocumentCommand{\vinjEx}{s D<>{I} D<>{i} O{\tau} m}{\IfBooleanTF{#1}{\vinjCst{#3}{#5}}{\vinjAbt{#2}{#3}{#4}{#5}}}
\NewDocumentCommand{\vcaseAbt}{m m m m m m m}{\Abt{\Opn{vcase}<#1>}[#4_#1\sep #3]{#5\sep \finmap*{#1}{#2}{\Abs(#6){#7}}}}
\NewDocumentCommand{\vcaseCst}{m m m m m}{\Opn{vcase}\, #3\,\{\finmap{#1}{#2}{\Abs(#4){#5}}\}}
\NewDocumentCommand{\vcaseEx}{s D<>{I} D<>{i} O{\tau} O{\rho} m m m}{\IfBooleanTF{#1}{\vcaseCst{#2}{#3}{#6}{#7}{#8}}{\vcaseAbt{#2}{#3}{#4}{#5}{#6}{#7}{#8}}}
% booleans, sum of one and one.
\NewDocumentCommand{\boolTy}{s}{\Abt{\IfBooleanTF{#1}{\Opn*{\mathbf{2}}}{\Opn{bool}}}{}}
\NewDocumentCommand{\trueEx}{s}{\Abt{\Opn{true}}{}}
\NewDocumentCommand{\falseEx}{s}{\Abt{\Opn{false}}{}}
\NewDocumentCommand{\ifEx}{s O{\rho} m m m}{\Abtsw{#1}{\Opn{if}}[#2]{#3\sep  #4\sep  #5}}

% total function type
\NewDocumentCommand{\arrAbt}{m m}{\Abt{\Opn{fun}}{#1\sep #2}}
\NewDocumentCommand{\arrCst}{m m}{#1\to #2}
\NewDocumentCommand{\arrTy}{s m m}{\IfBooleanTF{#1}{\arrCst{#2}{#3}}{\arrAbt{#2}{#3}}}
\NewDocumentCommand{\funTy}{s m m}{\IfBooleanTF{#1}{\arrCst{#2}{#3}}{\arrAbt{#2}{#3}}}
\NewDocumentCommand{\lamEx}{s O{\tau_1} O{\tau_2} m m}{\IfBooleanTF{#1}{\Abt*{\Opn*{\lambda}}}{\Abt{\Opn{lam}}}[#2\sep #3]{\Abs(#4){#5}}}
\NewDocumentCommand{\appEx}{s O{\tau_1} O{\tau_2} m m}{\Abtsw{#1}{\Opn{ap}}[#2\sep #3]{#4\sep #5}}

% inductive type; intro is foldex below
\NewDocumentCommand{\indTy}{s m m}{\Abt{\Opn{ind}}{\Abs(#2){#3}}}
\NewDocumentCommand{\inEx}{s O{t} O{\tau} m}{\Abtsw{#1}{\Opn{in}}[\Abs(#2){#3}]{#4}}
\NewDocumentCommand{\recEx}{s O{t} O{\tau} O{\rho} m m m}{\Abtsw{#1}{\Opn{rec}}[\Abs(#2){#3}\sep  #4]{#5\sep \Abs(#6){#7}}}

% coinductive type; elim is unfoldex below
\NewDocumentCommand{\coiTy}{s m m}{\Abt{\Opn{coi}}{\Abs(#2){#3}}}
\NewDocumentCommand{\outEx}{s O{t} O{\tau} m}{\Abtsw{#1}{\Opn{out}}[\Abs(#2){#3}]{#4}}
\NewDocumentCommand{\genEx}{s O{t} O{\tau} O{\sigma} m m m}{\Abtsw{#1}{\Opn{gen}}[\Abs(#2){#3}\sep #4]{#5\sep \Abs(#6){#7}}}

% yes/no answer type
\NewDocumentCommand{\ansTy}{s}{\Abt{\Opn{ans}}{}}
\NewDocumentCommand{\yesEx}{s}{\Abt{\Opn{yes}}{}}
\NewDocumentCommand{\noEx}{s}{\Abt{\Opn{no}}{}}

% continuation type
\NewDocumentCommand{\contTy}{s m}{\Abt{\Opn{cont}}{#2}}
\NewDocumentCommand{\contEx}{s m}{\Abt{\Opn{cont}}{#2}}
\NewDocumentCommand{\letccEx}{s O{\tau} m m}{\Abtsw{#1}{\Opn{letcc}}[#2]{\Abs(#3){#4}}}
\NewDocumentCommand{\throwEx}{s O{\tau} O{\rho} m m}{\Abtsw{#1}{\Opn{throw}}[#2\sep #3]{#4\sep  #5}}
% stacks
\NewDocumentCommand{\frmSlot}{s}{\Abt{\Opn*{\mathord{-}}}{}}
\NewDocumentCommand{\empStk}{s O{\tau}}{\IfBooleanTF{#1}{\Abt*{\Opn*{\varepsilon}}{}}{\Abt{\Opn{emp}}[#2]{}}}
\NewDocumentCommand{\extStk}{s O{\tau} O{\tau'} m m}{\IfBooleanTF{#1}{#4\mathbin{\kw{;}}#5}{\Abt{\Opn{ext}}[#2\sep #3]{#4\sep #5}}}

% universal and existential types
\NewDocumentCommand{\AllTy}{s m m}{\IfBooleanTF{#1}{\Abt{\Opn*{\forall}}}{\Abt{\Opn{All}}}{\Abs(#2){#3}}}
\NewDocumentCommand{\LamEx}{s m O{\tau} m}{\IfBooleanTF{#1}{\Abt*{\Opn*{\Lambda}}{\Abs(#2){#4}}}{\Abt{\Opn{Lam}}[\Abs(#2){#3}]{\Abs(#2){#4}}}}
\NewDocumentCommand{\AppEx}{s O{t} O{\tau} m m}{\Abtsw{#1}{\Opn{Ap}}[\Abs(#2){#3}]{#4\sep #5}}

\NewDocumentCommand{\SomeTy}{s m m}{\IfBooleanTF{#1}{\Abt*{\Opn*{\exists}}}{\Abt{\Opn{Some}}}{\Abs(#2){#3}}}
\NewDocumentCommand{\PackEx}{s O{t} O{\tau} m m}{\Abtsw{#1}{\Opn{Pack}}[\Abs(#2){#3}]{#4\sep  #5}}
\NewDocumentCommand{\OpenEx}{s O{t} O{\tau} m O{\rho} m m}{\Abtsw{#1}{\Opn{Open}}[\Abs(#2){#3}\sep #5]{#4\sep \Abs(#2,#6){#7}}}

% partial function type with recursive lambda, shares application form with total
\NewDocumentCommand{\parrAbt}{m m}{\Abt{\Opn{parr}}{#1\sep  #2}}
\NewDocumentCommand{\parrCst}{m m}{#1\mathbin{\rightharpoonup} #2}
\NewDocumentCommand{\parrTy}{s m m}{\IfBooleanTF{#1}{\parrCst{#2}{#3}}{\parrAbt{#2}{#3}}}
\NewDocumentCommand{\funEx}{s O{\tau_1} O{\tau_2} m m m}{\Abtsw{#1}{\Opn{fun}}[#2\sep #3]{\Abs(#4,#5){#6}}}
\NewDocumentCommand{\fixEx}{s O{\tau} m m}{\Abtsw{#1}{\Opn{fix}}[#2]{\Abs(#3){#4}}}

% recursive type
\NewDocumentCommand{\recTy}{s m m}{\Abt{\Opn{rec}}{\Abs(#2){#3}}}
\NewDocumentCommand{\foldEx}{s O{t} O{\tau} m}{\Abtsw{#1}{\Opn{fold}}[\Abs(#2){#3}]{#4}}
\NewDocumentCommand{\unfoldEx}{s O{t} O{\tau} m}{\Abtsw{#1}{\Opn{unfold}}[\Abs(#2){#3}]{#4}}
\NewDocumentCommand{\selfTy}{s m}{\Abt{\Opn{self}}{#2}}
\NewDocumentCommand{\rollEx}{s O{\tau} m}{\Abtsw{#1}{\Opn{roll}}[#2]{#3}}
\NewDocumentCommand{\selfEx}{s O{\tau} m m}{\Abtsw{#1}{\Opn{self}}[#2]{\Abs(#3){#4}}}

% untyped
\NewDocumentCommand{\ulamEx}{s m m}{\IfBooleanTF{#1}{\Abt*{\Opn*{\lambda}}}{\Abt{\Opn{lam}}}{\Abs(#2){#3}}}
\NewDocumentCommand{\uapEx}{s m m}{\IfBooleanTF{#1}{#2(#3)}{\Abt{\Opn{app}}{#2\sep #3}}}
\NewDocumentCommand{\uIEx}{s}{\Abt{\textbf{\kw{I}}}{}}
\NewDocumentCommand{\uKEx}{s}{\Abt{\textbf{\kw{K}}}{}}
\NewDocumentCommand{\uSEx}{s}{\Abt{\textbf{\kw{S}}}{}}
\NewDocumentCommand{\uBEx}{s}{\Abt{\textbf{\kw{B}}}{}}

% commands
\NewDocumentCommand{\cmdTy}{s m}{\Abt{\Opn{cmd}}{#2}}
\NewDocumentCommand{\cmdEx}{s O{\tau} m}{\Abtsw{#1}{\Opn{cmd}}[#2]{#3}}

\NewDocumentCommand{\retCmd}{s O{\tau} m}{\Abtsw{#1}{\Opn{ret}}[#2]{#3}}

\NewDocumentCommand{\bndAbt}{m m m m m}{\Abt{\Opn{bnd}}[#1\sep  #2]{#3\sep  \Abs(#4){#5}}}
\NewDocumentCommand{\bndCst}{m m m}{\Opn{bnd}\,#2\mathbin{\leftarrow}#1\mathbin{\kw{;}}#3}
\NewDocumentCommand{\bndCmd}{s O{\tau} m O{\rho} m m}{\IfBooleanTF{#1}{\bndCst{#3}{#5}{#6}}{\bndAbt{#2}{#4}{#3}{#5}{#6}}}

\NewDocumentCommand{\dclAbt}{m m m m}{\Abt{\Opn{dcl}}[#1\sep  #2]{#3\sep  #4}}
\NewDocumentCommand{\dclCst}{m m m}{\Opn{dcl}\,#2\mathbin{\kw{:=}}#1\,\kw{;}\,#3}
\NewDocumentCommand{\dclCmd}{s O{\tau} m O{\rho} m m}{\IfBooleanTF{#1}{\dclCst{#3}{#5}{#6}}{\dclAbt{#2}{#4}{#3}{\Abs<#5>{#6}}}}

% reference types
\NewDocumentCommand{\refAbt}{m}{\Abt{\Opn{ref}<#1>}{}}
\NewDocumentCommand{\refCst}{m}{\texttt{\&}\,#1}
\NewDocumentCommand{\refEx}{s m}{\IfBooleanTF{#1}{\refCst{#2}}{\refAbt{#2}}}

\NewDocumentCommand{\getAbt}{m}{\Abt{\Opn{get}<#1>}{}}
\NewDocumentCommand{\getCst}{m}{\Opn{!}{#1}}
\NewDocumentCommand{\getCmd}{s m}{\IfBooleanTF{#1}{\getCst{#2}}{\getAbt{#2}}}

\NewDocumentCommand{\getrefAbt}{m m}{\Abt{\Opn{getref}}[#1]{#2}}
\NewDocumentCommand{\getrefCst}{m}{\kw{*}#1}
\NewDocumentCommand{\getrefCmd}{s O{\tau} m}{\IfBooleanTF{#1}{\getrefCst{#3}}{\getrefAbt{#2}{#3}}}

\NewDocumentCommand{\setAbt}{m m}{\Abt{\Opn{set}<#1>}{#2}}
\NewDocumentCommand{\setCst}{m m}{#1\mathbin{\kw{:=}}#2}
\NewDocumentCommand{\setCmd}{s m m}{\IfBooleanTF{#1}{\setCst{#2}{#3}}{\setAbt{#2}{#3}}}

\NewDocumentCommand{\setrefAbt}{m m m}{\Abt{\Opn{setref}}[#1]{#2\sep  #3}}
\NewDocumentCommand{\setrefCst}{m m}{#1\mathbin{\kw{*{=}}} #2}
\NewDocumentCommand{\setrefCmd}{s O{\tau} m m}{\IfBooleanTF{#1}{\setrefCst{#3}{#4}}{\setrefAbt{#2}{#3}{#4}}}

% module types
\NewDocumentCommand{\univSg}{s}{\Abt{\Opn{type}}{}}
\NewDocumentCommand{\valSg}{s m}{\Abt{\Opn{val}}{#2}}

\NewDocumentCommand{\piAbt}{m m m}{\Abt{\Opn*{\prod}}{#1\sep \Abs(#2){#3}}}
\NewDocumentCommand{\piCst}{m m m}{#2{\mathbin{:}}#1\to #3}
\NewDocumentCommand{\piSg}{s m m m}{\IfBooleanTF{#1}{\piCst{#2}{#3}{#4}}{\piAbt{#2}{#3}{#4}}}

\NewDocumentCommand{\sigAbt}{m m m}{\Abt{\Opn*{\sum}}{#1\sep \Abs(#2){#3}}}
\NewDocumentCommand{\sigCst}{m m m}{#2{\mathbin{:}}#1\times #3}
\NewDocumentCommand{\sigSg}{s m m m}{\IfBooleanTF{#1}{\sigCst{#2}{#3}{#4}}{\sigAbt{#2}{#3}{#4}}}

\NewDocumentCommand{\extAbt}{m m}{\Abt{\Opn{Ext}}{#1\sep  #2}}
\NewDocumentCommand{\extCst}{m m}{\{#1\mid #2\}}
\NewDocumentCommand{\extSg}{s m m}{\IfBooleanTF{#1}{\extCst{#2}{#3}}{\extAbt{#2}{#3}}}

\NewDocumentCommand{\compAbt}{m}{\Abt{\Opn{Comp}}{#1}}
\NewDocumentCommand{\compCst}{m}{#1\,\kw{Comp}}
\NewDocumentCommand{\compSg}{s m}{\IfBooleanTF{#1}{\compCst{#2}}{\compAbt{#2}}}

% cbpv / polarization
\NewDocumentCommand{\posTy}{m}{#1^{\kw{+}}}
\NewDocumentCommand{\negTy}{m}{#1^{\kw{-}}}
\NewDocumentCommand{\freeTy}{s m}{\Abt{\Opn{F}}{#2}}
\NewDocumentCommand{\freeEx}{s O{\negTy{\tau}} m}{\Abtsw{#1}{\Opn{ret}}[#2]{#3}}
\NewDocumentCommand{\fletEx}{s O{\negTy{\tau}} O{\negTy{\rho}} m m m}{\Abtsw{#1}{\Opn{let}}[#2\sep #3]{#4\sep \Abs(#5){#6}}}
\NewDocumentCommand{\thunkTy}{s m}{\Abt{\Opn{U}}{#2}}
\NewDocumentCommand{\suspTy}{s m}{\Abt{\Opn{susp}}{#2}}  % for unpolarized uses
\NewDocumentCommand{\thunkEx}{s O{\negTy{\tau}} m}{\Abtsw{#1}{\Opn{thunk}}[#2]{#3}}
\NewDocumentCommand{\suspEx}{s O{\tau} m}{\Abt{\Opn{susp}}[#2]{#3}}   % for unpolarized uses
\NewDocumentCommand{\forceEx}{s m}{\Abt{\Opn{force}}{#2}}

% eager product
\NewDocumentCommand{\tensorTy}{s m m}{\IfBooleanTF{#1}{{#2}\otimes{#3}}{\Abt{\Opn{tens}}{#2\sep #3}}}
\NewDocumentCommand{\tensorEx}{s O{\tau_1} O{\tau_2} m m}{\IfBooleanTF{#1}{{#4}\otimes{#5}}{\Abt{\Opn{with}}[#2\sep  #3]{#4\sep  #5}}}
\NewDocumentCommand{\splitEx}{s O{\tau_1} O{\tau_2} O{\rho} m m m m}{\IfBooleanTF{#1}{\kw{split}\,{#5}\,\{\Abs(#6,#7){#8}\}}{\Abt{\Opn{split}}[#2\sep #3\sep #4]{#5\sep \Abs(#6,#7){#8}}}}

% lazy, not memoized, product
\NewDocumentCommand{\bothTy}{s m m}{\IfBooleanTF{#1}{#2\mathbin{\&} #3}{\Abt{\Opn{and}}{#2\sep #3}}}
\NewDocumentCommand{\bothEx}{s m m}{\IfBooleanTF{#1}{#2\mathbin{\&} #3}{\Abt{\Opn{both}}{#2\sep #3}}}
\NewDocumentCommand{\parEx}{s m m m m}{\Abt{\Opn{par}}{#2\sep \Abs(#3,#4){#5}}}
